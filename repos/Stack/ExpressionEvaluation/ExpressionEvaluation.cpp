#include <stack>
#include <stdio.h>

using namespace std;

char str[220];
int mat[][5] = {
	/*
	优先级矩阵，若mat[i][j] == 1,则表示i号运算优先级
	大于j号运算符，运算符编码规则为+为1号，-为2号，*为
	3号，/为4号，我们人为添加在表达式首尾的标记运算符为
	0号
	*/
	1, 0, 0, 0, 0,
	1, 0, 0, 0, 0,
	1, 0, 0, 0, 0,
	1, 1, 1, 0, 0,
	1, 1, 1, 0, 0,
};

stack<int> op; //运算符栈，保存运算符编号
stack<double> in;
//数字栈，运算结果可能存在浮点数，所以保存元素为double

void getOp(bool &reto, int &retn, int &i) {
	/*
	获得表达式中下一个元素函数，若函数运行结束时，
	引用变量reto为true，则表示该元素为一个运算符，
	其编号保存在引用变量retn中；否则，表示该元素为
	一个数字，其值保存在引用变量retn中，引用变量i
	表示遍历
	*/
	if (i == 0 && op.empty() == true) {
		reto = true; //
		retn = 0;
		return;
	}

	if (str[i] >= '0' && str[i] <= '9') {
		reto = false; //
	}

	else {
		reto = true;
		if (str[i] == '+') {
			retn = 1;
		}
		else if (str[i] == '-') {
			retn = 2;
		}
		else if (str[i] == '*') {
			retn = 3;
		}
		else if (str[i] == '/') {
			retn = 4;
		}

		i += 2;
		return;
	}
	retn = 0;
	for (; str[i] != ' ' && str[i] != 0; i++) {
		retn *= 10;
		retn += str[i] - '0';

	}
	if (str[i] == ' ') i++;
	return;

}

int main() {
	while (scanf("%s", str)) {
		if (str[0] == '0' && str[1] == 0) break;
		bool retop; int retnum;
		int idx = 0;
		while (!op.empty()) op.pop();
		while (!in.empty()) in.pop();
		while (true) {
			getOp(retop, retnum, idx);
			if (retop == false) {
				in.push((double)retnum);

			}
			else {
				double tmp;
				if (op.empty() == true ||
					mat[retnum][op.top()] == 1) {
					op.push(retnum);
				}
				else {
					while (mat[retnum][op.top()] == 0) {
						int ret = op.top();
						op.pop();
						double b = in.top();
						in.pop();
						double a = in.top();
						in.pop();
						if (ret == 1) tmp = a + b;
						else if (ret == 2) tmp = a - b;
						else if (ret == 3) tmp = a * b;
						else tmp = a / b;
						in.push(tmp);

					}
					op.push(retnum);

				}
			}
			if (op.size() == 2 && op.top() == 0) break;

		}
		printf("%.2f\n", in.top());
	} //while 
	return 0;
} //main 