echo $? #返回值为0说明命令执行成功，不是0说明执行不成功
#vim
I 行首插入
X 向前删除一个字符
yy 复制一行
yw 复制一个单词
y$ 复制到行尾
w 切换单词

v模式：
多行注释
(1)ctrl + v 进入v模式
(2)向上或向下移动光标
(3)把需要注释的行的开头标记起来
(4)然后按大写的I
(5)在插入注释符，比如#
(6)在退回到命令模式，即完成注释
删除多行注释
前面的步骤相似，上下移动选中之后，
无需按I，直接输入d

替换
% 引导全局替换
5, 10 替换第5到10行 ，具体命令如下：5,10s/xxx/xxx/g 

有关行号
显示行号 ：set nu
取消行号 ：set nonu

取消高亮 ：noh 

定位 ：出命令行输入行号，也可以直接输入行号，然后按gg或G

读入文件 ：r 文件路径

打开多个文件 ：vim -o xxx xxx xxx #竖排
               vim -O xxx xxx xxx #竖排
多个文件之间切换 ：ctrl + ww

自定义vim
set nu #显示行号
set history=10 #保存10条历史命令

在“etc/bin”中的“etc”真正代表的是“etcetera”(附加物)。在
早期的Unix系统中，最为重要的目录是“bin”目录 (“bin”是
“binaries”二进制文件――编译后的程序的缩写)，“etc”中则包
含琐碎的程序，如启动、关机和管理。运行一个Linux必须的东
西的列表是:一个二进制程序，etcetera，etcetera――换句话说，
是一个底层的重要项目，通常添加一些次等重要的零碎事物。
今天， “etc”包含了广泛的系统配置文件，这些配置文件几乎
包含了系统配置的方方面面，同样非常重要。

#配置文件，包含所有应用程序的配置文件，也包括启动和关闭
特定程序的脚本
/etc

#存放linux系统启动时需要加载的文件，包括kernel，grub等
/boot

#可增长目录，包含很多经常变化的文件，如/var/log（系统日志），/var/lib（包文件）
/var

#管理员数据存放目录，相当于root用户的家目录
/root

#临时文件存储目录
/tmp

#usr 表示 unix software source
/usr

#命令 此目录包含二进制可执行文件
/bin

#系统命令 此目录中的命令主要供系统管理员使用，以进行系
统维护，如 iptables，reboot，fdisk等
/sbin

#挂载目录，系统管理员可用于临时挂载文件系统
#实际上挂载点对操作没有影响
/mnt

#包含设备文件，在Linux下，终端设备，usb，磁盘等都被看作
文件，如/dev/sda
/dev

#普通用户所有数据存放在该目录下
/home

#这个目录是一个虚拟的目录，它是系统内存的映射，可以通过
直接访问这个目录获取系统信息。也就是说，这个目录的内容
不在硬盘而在内存里
/proc

#用于存放最基本的动态链接共享库，其作用类似于windows的
dll文件。几乎所有的应用程序都需要用到这些共享库

#~代表登陆用户的宿主目录

#单独敲“cd”米命令就可进入当前用户宿主目录

#hwclock 查看bios相关的硬件时间，非管理员用户需要提权
#date  查看系统时间，与bios时间差8小时，可以修改

#help xxx 查看内部命令帮助信息
#xxx --help 查看外部命令帮助信息

#ll 参数-d可查看文件夹信息，参数-h以人可阅读的方式显示

#cd ../../ 进入父目录的父目录『

#linux系统下“一切皆文件”，目录也是一种文件，
所以同一目录下不可能存在同名的目录或文件。

#用于创建文件
touch xxx

#用于查看文件，回车一次翻一行，空格一次翻一页
#不支持后退
more xxx

#用于显示前n行(此处是前3行)
head -n 3 xxx
或者：head -3 xxx
#tail与head正好相反，注意-f参数可以动态追踪正在变化的文件

#查看文件第5行
head -n 5 xxx | tail -n 1

#切换终端
#Ubuntu 18.04
ctrl + alt + f1 ... f6 分别对应tty1到6
其中tty1为图形终端
#一般情况如下
Ubuntu 系统与 CentOS 系统在终端操作上的区别
Ubuntu 系统切换到字符界面： Ctrl+Alt+Fn（n=1…6）；切换回图形界面： Ctrl+Alt+F7 或 Alt+F7。
CentOS 系统切换到字符界面： Ctrl+Alt+Fn（n=2…6）；切换回图形界面： Ctrl+Alt+F1 或 Alt+F1

#切换运行级别，注意和切换终端区别
systemctl isolate multi-user.target #切换到第3运行级别
或systemctl isolate runlevel3.target

systemctl isolate graphical.target #切换到第5运行级别
或systemctl isolate runlevel5.target

systemtcl get-default #获取当前系统默认的启动级别
systemtcl set-default xxx #设置默认的启动级别

#iconv 转码命令
iconv -f 原文件的编码(Windows下是gb2312) 源文件名 -o 输入文件名
#linux脚本在Windows桌面打开异常，这是因为Windows和linux
#对回车键处理的不同，linux处理回车"\n"，Windows处理回车"\r\n"
解决方法一：通过Windows写字板或者MSWord打开
解决方法二：通过dos2unix包的unix2dos命令打开

#查看pip安装的软件列表
pip freeze

#查看软件包安装情况，非常好用
aptitude

#进程查看
pstree 查看进程树 -p 参数显示进程号
ps -aux 列出目前所有的正在内存中的进程(以BSD格式显示)
ps -ef 列出目前所有的正在内存中的进程(以标准格式显示)
ps -aux | head -5
#结果解释
USER(运行此进程的用户名)    PID(进程号) %CPU %MEM    VSZ(虚拟内存使用)   RSS(占用的固定内存) TTY(运行终端)      STAT(状态) START(进程被触发运行的时间)   TIME(进程实际使用cpu的时间) COMMAND(由哪个命令所执行)
#TTY:该进程是在哪个终端上运行，若与终端无关，则显示？，另外tty1-tty6是本机上的登入者程序，若为pts/0等等的，则表示为由网络连接进主机的程序
#STAT:该进程目前的状态，Linux进程有5种基本状态：
    R：正在运行或正在运行队列种等待
    S：该程序目前正在睡眠(sleep)当中，但可被某些讯号唤醒(signal)
    T: 该程序目前暂停了(ctrl + z)
    Z：该程序已经终止，但是其子程序却无法正常终止，造成zombie(僵尸)程序的状态
    D：不可中断状态
    ctal + c 发送SIGINT信号，终止一个进程
    ctrl + z 发送SIGSTOP信号，挂起一个进程
        < 高优先级的
        N 低优先级的
        s 包含子进程
        l 多线程
        + 前台程序

#top命令用于查看活动进程(没3s刷新一次)
top -p 进程号 #用于查看对应进程的信息
第一行是任务队列信息 同uptime的执行结果
uptime
10:12:12 up  2:27,                1 user,        load average: 0.60, 0.66, 0.51
当前时间 系统运行时间,格式为时:分 当前登录用户数 系统负载,即任务队列的平均长度
                                                 三个值分别为1min,5min,15min前到现在的平均值
#一般来说，每个cpu内核当前活动进程数不大于3，则系统运行
#变现良好！当然，这里说的是每个cpu内核，也就是说你的主机
#如果是四核cpu的话，那么只要uptime最后输出的一串字符数值
#小于4*3=12即表示系统负载不是很严重
#
#按空格可以立即刷新
#M对内存排序显示，P对cpu排序显示
#>往下翻页，<往上翻页

#kill 控制(关闭)进程
常用信号：
1 HUP 重新加载配置文件，类似重启
2 INT 和ctrl+c 一样，一般用于通知前台进程组终止进程
9 KILL 强行中断(杀死某个进程)
19 STOP 和ctrl+z类似

killall xxx #通过程序名称杀死所有的进程
或者用pkill也可以

#优先级控制(top中的NI列即为优先级)
nice值 -20~19 越小优先级越高 普通用户0~19
#nice控制优先级
nice -n 优先级数字(-20~19) 执行命令 
如：nice -n -5 vim a.txt #静态优先级控制
renice -n 5 PID #动态优先级控制

#查看后台进程
jobs
命令 & #可以创建后台进程
#把后台进程调到前台
fg 对应序号

#查看内存使用状况
free -m #m参数表示以mb为单位
#buffer缓冲从磁盘中读出的内容
#cache缓存需要写入磁盘的内容
#目前以不在度buffer和cache分开存放

#清空缓存
方式一：reboot
方式二：echo 3 > /proc/sys/vm/drop_caches

#nohup ctrl+z & 等方式创建的后台进程是临时性的，
#关闭终端即停止
screen #可以创建在终端关闭后继续运行的后台进程
(1)键入scree
(2)创建后台指令
(3)ctrl + a + d  出现detached表明挂起成功，
    可以关闭终端 #将指令调到后台
(4)screen -ls #查看挂起的终端命令
(5)screen -r 编号(步骤(4)显示的)#调出挂起程序

文件描述符：内核利用文件描述符(file descriptor)来访问文
件。文件描述符是非负整数。打开现存文件或新建文件时，内
核会返回一个文件描述符。读写文件也需要使用文件描述符来
制定待读写的文件。
linux下一切皆文件
STDIN 标准输入 如：键盘文件 文件描述符：0
STDOUT 标准输出 屏幕终端 文件描述符：1
STDERR 错误输出 屏幕终端 文件描述符：2
/dev/null #黑洞文件，多余信息可以放入
输出重定向： 
> #标准输出重定向到xxx，这里1缺省
1> #同一个意思，1代表标准输出
#注意以上操作，不对错误内容进行重定向
2> #表示标准错误输出的重定向，只记录错误的内容，可以对
   #错误内容重定向
2> xxx >&2 #将正确和错误内容都重定向到xxx，&是等同于的
           #意思，1>等同于2(1省略)
&> #表示混合输出 &> xxx 作用同上
输入重定向：
< 

wc xxx  #查看文件的行数、字数、字节数
269  457                 9651    note.txt.link
函数 字数(以空格为分隔符)  字节数

tee #将输入重定向到文件，同时输出到屏幕
-a 可以追加

which #查看可执行文件的位置，会打印出绝对路径
whereis #查看可执行文件的位置及相关信息，打印出路径
locate #配合数据库缓存，快速查看文件位置，
       #新建的文件查找不到，用updatedb更新一下数据库即可

grep #对文件进行过滤，查找出包含指定内容的行
     #标准书写应对查找内容加引号，某些情况下不加引号可
     #能无法查找出内容
-v 反转，查找出文件中不带xxx内容的行


#搜索文件
find / -name ipython

